# Software

As software heavily relies on hardware, hardware is just some rubbish without any software. Years of development in Computer Science led us to the point where a programmer shouldn't really care about the underlying hardware. Modern programming languages implement dozens of sufficient abstractions focused on getting away from hardware things.

## Proprietary vs Open source
First of all, you ought to understand the difference between proprietary and open source software. Spoiler: it's damn huge. Proprietary software is developed "privately" and is being distributed in binaries only. A good example of a proprietary application is Microsoft Office® Word. It's being developed in the dark chambers of Microsoft and distributed on subscription basis in binaries. It makes perfect sense: why would Microsoft want to publish sources of Word?

Now let's take a look at open source software. Unlike proprietary, Open source software is software that can be freely used, changed, and shared (in modified or unmodified form) by anyone. Open source software is made by many people, and distributed under corresponding licenses. Needless to say, open source software is not neccesarily free in terms of freedom (aka Free software). There is an adorable related question on Stack: [Is there a difference between free software and open source software?](http://askubuntu.com/questions/78958/is-there-a-difference-between-free-software-and-open-source-software) which you should definitely consider reading.

World wouldn't have been the same without the open source software. We use it everywhere: e.g. proprietary OS X is built on top of FreeBSD, which is a perfect sample of open source software. There are also dozens of generally accepted popular open source applications. For instance, Chromium, a free web browser Google Chrome® is built on top of.

Yet another important point of OSS is licensing: there are multiple open source licenses out there. I don't really want to talk about it in this particular chapter of this particular book, but in case if you are interested in the subject, take a look at [choosealicense.com](choosealicense.com), which briefly explains what differs one license from another.

## Use cases
Different use cases require application of different software. For desktop systems, you'd typically go with some object-driven languages (like Java, C++ or C#) and GUI (Graphical User Interface) frameworks for these languages. For system programming (networking, processing, etc) you might want to put Python, Go, C or even Scala in the shed. Use cases tend to heavily overlap, e.g. C++ is often used for literally any kind of software: starting with GUI, finishing with low-latency web computing platforms. Funky fact: I am not saying that you should learn C++; it's a great and accomplished language that I'd been coding with since 2010, but hold on, you mustn't start with it—C++ is a deep sea of frustration and a valley of pitfalls for a beginner.

Modern PCs have 4+ GB of RAM, which is _a lot_. But we don't program computers only, don't we? There is a huge field in software engineering, called **Embedded programming**. Basically, it's all about programming chips and all sorts of microcontrollers. These might have about 16 KB of RAM, which puts a whole bunch of limitations for programmer on. You definitely can't go with Java on embedded, since it's a memory hog. You can't go with most other languages, including Go (usually), for exactly the same reason: memory and performance. Embedded is a kingdom of C/C++ and potentially, Rust.

## Library linking
It usually makes more sense to build source code into _libraries_. Basically, a library is a collection of implementations of behavior, written in terms of a language, that has a well-defined interface by which the behavior is invoked. This means that as long as a higher level program uses a library to make system calls, it does not need to be re-written to implement those system calls over and over again. In addition, the behavior is provided for reuse by multiple independent programs. A program invokes the library-provided behavior via a mechanism of the language. For example, in a simple imperative language such as C, the behavior in a library is invoked by using C's normal function-call. What distinguishes the call as being to a library, versus being to another function in the same program, is the way that the code is organized in the system.

When linking is performed during the creation of an executable or another object file, it is known as _static linking_ or _early binding_. In this case, the linking is usually done by a linker, but may also be done by the compiler. A static library, also known as an archive, is one intended to be statically linked. Originally, only static libraries existed. Static linking must be performed when any modules are recompiled. All of the modules required by a program are sometimes statically linked and copied into the executable file. This process, and the resulting stand-alone file, is known as a static build of the program. A static build may not need any further relocation if virtual memory is used and no address space layout randomization is desired.

A _shared library_ or _shared object_ is a file that is intended to be shared by executable files and further shared object files. Modules used by a program are loaded from individual shared objects into memory at load time or run time, rather than being copied by a linker when it creates a single monolithic executable file for the program. Shared libraries can be statically linked, meaning that references to the library modules are resolved and the modules are allocated memory when the executable file is created. But often linking of shared libraries is postponed until they are loaded.

## Cross-platform development
The software and methods of cross-platform development are said to be platform independent. Cross-platform software may be divided into two types; one requires individual building or compilation for each platform that it supports, and the other one can be directly run on any platform without special preparation: software written in an interpreted language or pre-compiled portable bytecode for which the interpreters or run-time packages are common or standard components of all platforms. For example, a cross-platform application may run on Microsoft Windows on the x86 architecture, Linux on the x86 architecture and Mac OS X on either the PowerPC or x86 based Apple Macintosh systems. Cross-platform programs may run on as many as all existing platforms, or on as few as two platforms.

Here are certain issues associated with cross-platform development. Some of these include:
* Testing cross-platform applications may be considerably more complicated, since different platforms can exhibit slightly different behaviors or subtle bugs.
* Developers are often restricted to using the lowest common denominator subset of features which are available on all platforms. This may hinder the application's performance or prohibit developers from using platforms’ most advanced features.
* Different platforms often have different user interface conventions, which cross-platform applications do not always accommodate. For example, applications developed for Mac OS X and GNOME are supposed to place the most important button on the right-hand side of a window or dialog, whereas Microsoft Windows and KDE have the opposite convention.
* Scripting languages and virtual machines must be translated into native executable code each time the application is executed, imposing a performance penalty. This penalty can be alleviated using advanced techniques like just-in-time compilation; but even using such techniques, some computational overhead may be unavoidable.
* Different platforms require the use of native package formats such as RPM and MSI. Multi-platform installers such as InstallAnywhere address this need.
* Cross-platform execution environments may suffer cross-platform security flaws, creating a fertile environment for cross-platform malware.
